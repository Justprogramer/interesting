package com.tao.swordoffer;

/**
 * @author: Penger
 * @time: 2019/3/27
 * @description: <p>
 * 把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。
 * </p>
 * @solution: <p>
 * 根据丑数的定义， 丑数应该是另一个丑数乘以 2、3 或者 5 的结果（1 除外）。因此我们可以创建一个数组，里面的数字是排好序的丑数，每一个丑数都是前面的丑数乘以 2、3 或者 5 得到的。
 * <p>
 * 这种思路的关键在于怎样确保数组里面的丑数是排好序的。
 * 假设数组中已经有若干个丑数排好序后存放在数组中，并且把己有最大的丑数记做M，我们接下来分析如何生成下一个丑数。
 * 该丑数肯定是前面某一个丑数乘以 2、3 或者 5 的结果， 所以我们首先考虑把已有的每个丑数乘以 2。在乘以 2 的时钝能得到若干个小于或等于 M 的结果。
 * 由于是按照顺序生成的，小于或者等于 M 肯定己经在数组中了，
 * 我们不需再次考虑：还会得到若干个大于 M 的结果，但我们只需要第一个大于 M 的结果，因为我们希望丑数是按从小到大的顺序生成的，其他更大的结果以后再说。
 * 我们把得到的第一个乘以 2 后大于 M 的结果记为 M2，同样，我们把已有的每一个丑数乘以 3 和 5，能得到第一个大于 M 的结果 M3 和 M，那么下一个丑数应该是 M2、M3 和 M5 这 3 个数的最小者。
 * <p>
 * 前面分析的时候，提到把已有的每个丑数分别都乘以 2、3 和 5。
 * 事实上这不是必须的，因为已有的丑数是按顺序存放在数组中的。
 * 对乘以 2 而言， 肯定存在某一个丑数 T2，排在它之前的每一个丑数乘以 2 得到的结果都会小于已有最大的丑数，在它之后的每一个丑数乘以 2 得到的结果都会太大。
 * 我们只需记下这个丑数的位置， 同时每次生成新的丑数的时候，去更新这个 T2。
 * 对乘以 3 和 5 而言， 也存在着同样的 T3 和 T5。
 * </p>
 **/
public class UglyNumber {
    private static int getUglyNumber(int index) {
        if (index <= 0) {
            return 0;
        }
        if (index == 1) {
            return 1;
        }
        int t2 = 0, t3 = 0, t5 = 0;
        int[] res = new int[index];
        res[0] = 1;
        for (int i = 1; i < index; i++) {
            res[i] = Math.min(res[t2] * 2, Math.min(res[t3] * 3, res[t5] * 5));
            while (res[i] >= res[t2] * 2) {
                t2++;
            }
            while (res[i] >= res[t3] * 3) {
                t3++;
            }
            while (res[i] >= res[t5] * 5) {
                t5++;
            }
        }
        return res[index - 1];
    }

    public static void main(String[] args) {
        System.out.println(getUglyNumber(10));
    }
}
